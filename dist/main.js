/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/actor.js":
/*!**********************!*\
  !*** ./src/actor.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Actor)\n/* harmony export */ });\n/* harmony import */ var _sprite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sprite.js */ \"./src/sprite.js\");\n/* harmony import */ var _hitbox_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hitbox.js */ \"./src/hitbox.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n/* harmony import */ var _hiteffect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hiteffect.js */ \"./src/hiteffect.js\");\n\n\n\n\n\nclass Actor extends _sprite_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor({vel, pos, r, health, speed, img, dir, state}, scene) {\n        super({vel: vel, pos: pos, r: r, img: img});\n\n        if (!health) { this.health = 5;}\n        else {this.health = health;}\n        if (!speed) { this.speed = 60;}\n        else {this.speed = speed;}\n        if (!dir) { this.dir = 148;}\n        else {this.dir = dir;}\n        if (!state) { this.state = \"idle\";}\n        else {this.state = state;}\n        this.stateLock = false;\n        this.timeEnteredState = new Date();\n\n        this.scene = scene;\n        this.hitbox = undefined;\n        this.hitBy = undefined;\n        this.timeHit = undefined;\n\n        this.states = {\n            \"idle\": [\"attack\", \"moving\", \"death\"],\n            \"attack\": [\"idle\", \"death\"],\n            \"moving\": [\"idle\", \"attack\", \"death\"],\n            \"death\": []\n        };\n    }\n\n    tick(dt) {\n        switch(this.state) {\n            case \"idle\": {this.idle(); break;}\n            case \"attack\": {this.attack(); break;}\n            case \"moving\": {this.moving(); break;}\n            case \"death\": {this.death(); break;}\n        }\n        if (this.hitBy) this._hit(dt);\n    }\n\n    changeState(newState) {\n        if (!this.stateLock || newState === 'death'){\n            if (this.states[this.state].includes(newState)) {\n                if (this.hitbox) {\n                    this.scene.removeHitbox(this.hitbox);\n                    this.hitbox = undefined;\n                }\n                this.state = newState;\n                this.timeEnteredState = new Date();\n            }\n        }\n    }\n\n    idle() {\n        // console.log(\"please override idle()!\");\n    }\n\n    attack() {\n        // console.log(\"please override attack()!\");\n    }\n\n    moving() {\n        // console.log(\"please override moving()!\");\n    }\n\n    death() {\n        // console.log(\"please override death()!\");\n    }\n\n    hit(hb) {\n        if (!this.hitBy) { //initial hit frame\n            this.hitBy = hb;\n            this.timeHit = Date.now();\n            this.blockCheck(hb);\n        }\n    }\n    \n    blockCheck(hb) { //overridden in Player\n        if (this.health > 0) this.health--;\n        this.addHitEffect(hb);\n    }\n\n    addHitEffect(hb) { //overridden in Player\n        let effectPos = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.scaleVector)((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.dirToVector)(hb.dir), 20);\n        new _hiteffect_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\n                x:effectPos.x + this.pos.x,\n                y:effectPos.y + this.pos.y\n            }, this.scene, false);\n    }\n\n    _hit(dt) {\n        let timeElapsed = Date.now() - this.timeHit;\n        if (timeElapsed < 400) {\n            this.pushBack(400 - timeElapsed, dt);\n            this.color = \"red\";\n        } else {\n            this.vel = {x:0,y:0}; \n            this.hitBy = undefined;\n            this.color = \"white\";\n        }\n    }\n\n    pushBack(factor, dt) {\n        let pushVector = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.dirToVector)(this.hitBy.dir);\n        pushVector = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.scaleVector)(pushVector, -1);\n        this.pos.x += pushVector.x * factor * dt;\n        this.pos.y += pushVector.y * factor * dt;\n    }\n\n    createHitbox(size = 1.2) {\n        let hbr = this.r * size;\n        let hbPos = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.scaleVector)((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.dirToVector)(this.dir), (hbr + this.r + 4) * (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.dirScaleFactor)(this.dir) * -1);\n        let hitbox = new _hitbox_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({ \n            pos: {\n                x: this.pos.x + hbPos.x,\n                y: this.pos.y + hbPos.y\n            },\n            r: hbr,\n            owner: this,\n            dir: this.dir\n        });\n        return hitbox;\n    }\n\n    collisionHandle(bd) {\n        let error = Math.abs(bd.distToObj(this) - this.r);\n        let correction = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.scaleVector)({x:bd.normal.x,y:bd.normal.y}, -1 * error);\n        this.pos.x += correction.x;\n        this.pos.y += correction.y;\n    }\n\n    disperse() { //overridden in Enemy\n\n    }\n}\n\n//# sourceURL=webpack://js_project/./src/actor.js?");

/***/ }),

/***/ "./src/assets.js":
/*!***********************!*\
  !*** ./src/assets.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"loadAssets\": () => (/* binding */ loadAssets)\n/* harmony export */ });\nwindow.bgSprites = {};\nwindow.playerSprites = {};\nwindow.enemySprites = {};\nwindow.effectSprites = {};\n\nconst loadAssets = async () => {\n    await loadBackgroundSprites();\n    await loadPlayerSprites();\n    await loadEnemySprites();\n    await loadEffectSprites();\n    return true;\n};\n\nconst loadBackgroundSprites = async () => {\n    let path = '../assets/background';\n    let names = [\n        'ground0', 'ground1', 'archway0', 'wall0'\n    ];\n    names.forEach((name) => {\n        let img = new Image();\n        img.src = `${path}/${name}.png`;\n        bgSprites[name] = img;\n    })\n};\n\nconst loadPlayerSprites = async () => {\n    let path = '../assets/player';\n    let dirs = [148, 65, 152, 87, 155, 68, 151, 83];\n    let frames = [\n        'attack_1', 'attack_2', 'attack_3', \n        'idle', \n        'move_1', 'move_2', 'move_3', 'move_4',\n        'strafe_1', 'strafe_2', 'strafe_3'\n    ];\n    dirs.forEach((dir) => {\n        playerSprites[dir] = {};\n        frames.forEach((frame) => {\n            let img = new Image();\n            img.src = `${path}/${dir}/${frame}.png`;\n            playerSprites[dir][frame] = img;\n        })\n    })\n};\n\nconst loadEnemySprites = async () => {\n    let path = '../assets/enemy';\n    let dirs = [148, 65, 152, 87, 155, 68, 151, 83];\n    let frames = [\n        'attack_1', 'attack_2', 'attack_3', 'attack_4',\n        'idle',\n        'move_1', 'move_2',\n        'death_1', 'death_2', 'death_3', 'death_4'\n    ];\n    dirs.forEach((dir) => {\n        enemySprites[dir] = {};\n        frames.forEach((frame) => {\n            let img = new Image();\n            img.src = `${path}/${dir}/${frame}.png`;\n            enemySprites[dir][frame] = img;\n        })\n    })\n};\n\nconst loadEffectSprites = async () => {\n    let path = '../assets/effects';\n    let names = [\n        'spawn_1', 'spawn_2', 'spawn_3',\n        'block_1', 'block_2', 'block_3',\n        'hit_1', 'hit_2', 'hit_3'\n    ];\n    names.forEach((name) => {\n        let img = new Image();\n        img.src = `${path}/${name}.png`;\n        effectSprites[name] = img;\n    })\n};\n\n//# sourceURL=webpack://js_project/./src/assets.js?");

/***/ }),

/***/ "./src/boundary.js":
/*!*************************!*\
  !*** ./src/boundary.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Boundary)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n\n\nclass Boundary {\n    constructor({ pos, delta, normal }) {\n        this.pos = pos;\n        if (!pos) this.pos = {\n            x:0, y:0\n        };\n        this.delta = delta;\n        if (!delta) this.delta = {\n            x:50, y:50\n        };\n        this.normal = normal;\n    }\n\n    distToObj(go) {\n        let pos = this.pos;\n        let delta = this.delta;\n        let objectVector = {\n            x: go.pos.x - pos.x,\n            y: go.pos.y - pos.y\n        }\n        let projectionScale = _utils_js__WEBPACK_IMPORTED_MODULE_0__.dot(objectVector, delta) / (_utils_js__WEBPACK_IMPORTED_MODULE_0__.mag(delta)** 2);\n        let projectionDelta = _utils_js__WEBPACK_IMPORTED_MODULE_0__.scaleVector({x:delta.x, y:delta.y}, projectionScale);\n\n        let distance = _utils_js__WEBPACK_IMPORTED_MODULE_0__.mag({\n            x: (go.pos.x) - (projectionDelta.x + pos.x),\n            y: (go.pos.y) - (projectionDelta.y + pos.y)\n        });\n        return distance;\n    }\n\n    draw(ctx) {\n        let pos = this.pos;\n        let delta = this.delta;\n        ctx.strokeStyle = \"yellow\";\n        ctx.beginPath();\n        ctx.moveTo(pos.x, pos.y);\n        ctx.lineTo(pos.x + delta.x, pos.y + delta.y);\n        ctx.stroke();\n    }\n}\n\n//# sourceURL=webpack://js_project/./src/boundary.js?");

/***/ }),

/***/ "./src/enemy.js":
/*!**********************!*\
  !*** ./src/enemy.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Enemy)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n/* harmony import */ var _actor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./actor.js */ \"./src/actor.js\");\n\n\n\nconst CONST = {\n    \"SPEED\": 60,\n    \"HEALTH\": 3,\n    \"RADIUS\": 40,\n    \"AGGRO\": 120,\n    \"VALUE\": 200\n}\n\nclass Enemy extends _actor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n    constructor(pos, scene) {\n        super({\n            vel: {x:0,y:0},\n            pos: pos,\n            r: CONST[\"RADIUS\"],\n            img: undefined,\n            health: CONST[\"HEALTH\"],\n            speed: CONST[\"SPEED\"],\n            state: \"moving\"\n        }, scene);\n        this.player = this.scene.player;\n        this.absoluteSpeed = this.speed;\n        this.velVector = {x:0, y:0};\n\n        setInterval(() => { //Set dir based off player pos\n            if (!this.stateLock) {\n                this._setDirFromAngle();\n                this._setVelAndSpeed();\n            }\n        }, 500);\n    }\n    \n    tick(dt) {\n        // this.vel = {x:20, y:0};\n        if (this.health <= 0) this.changeState(\"death\");\n        this.setSprite(\"idle\");\n        super.tick(dt);\n    }\n\n    idle() {\n        this.stateLock = false;\n        if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.dist(this.player.pos, this.pos) < CONST[\"AGGRO\"]) {\n            this.changeState(\"attack\");\n        } else {\n            this.changeState(\"moving\");\n        }\n    }\n\n    attack() {\n        this._setDirFromAngle();\n        this.stateLock = true;\n        this.vel = {x:0, y:0};\n        let timeElapsed = (Date.now() - this.timeEnteredState);\n        if (timeElapsed < 400) { //wind up\n            this.setSprite(\"attack_1\");\n            this.color = \"white\";\n        } else if (timeElapsed < 800) { //spawn hitbox\n            this.setSprite(\"attack_2\");\n            if (!this.hitbox){\n                this.hitbox = this.createHitbox();\n                this.scene.addHitbox(this.hitbox);\n            }\n        } else if (timeElapsed < 1000) {// despawn hitbox / recovery\n            this.setSprite(\"attack_3\");\n            if (this.hitbox) {\n                this.scene.removeHitbox(this.hitbox);\n                this.hitbox = undefined;\n            }\n        } else if (timeElapsed < 1200) {\n            this.setSprite(\"attack_4\");\n        } else {\n            this.stateLock = false;\n            this.color = \"green\";\n            this.changeState(\"idle\");\n        }\n\n    }\n\n    death() {\n        let timeElapsed = Date.now() - this.timeEnteredState;\n        this.stateLock = true;\n        // console.log(\"i am dead...\");\n        this.color = \"black\";\n        if (timeElapsed < 600) {\n            this.setSprite('death_1');\n        } else if (timeElapsed < 800){\n            this.setSprite('death_2');\n        } else if (timeElapsed < 1000) {\n            this.setSprite('death_3');\n        } else if (timeElapsed < 1200) {\n            this.setSprite('death_4');\n        } else {\n            this.scene.removeGameObject(this);\n            this.scene.score += CONST[\"VALUE\"];\n            this.player.killCount++;\n        }\n    }\n    \n    moving() {\n        this.stateLock = false;\n        let timeElapsed = (Date.now() - this.timeEnteredState) % 800;\n        if (timeElapsed < 400) {\n            this.setSprite(\"idle\");\n        } else if (timeElapsed < 600) {\n            this.setSprite(\"move_1\");\n        } else if (timeElapsed < 800) {\n            this.setSprite(\"move_2\");\n        }\n        this.vel.x = this.velVector.x * this.speed;\n        this.vel.y = this.velVector.y * this.speed;\n        if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.dist(this.player.pos, this.pos) < CONST[\"AGGRO\"]) {\n            this.changeState(\"attack\");\n        }\n    }\n\n    setSprite(frame) {\n        this.img = enemySprites[this.dir][frame];\n    }\n\n    _setVelAndSpeed() {\n        this.velVector = _utils_js__WEBPACK_IMPORTED_MODULE_0__.scaleVector(_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirToVector(this.dir), -1);\n        this.speed = this.absoluteSpeed * _utils_js__WEBPACK_IMPORTED_MODULE_0__.dirScaleFactor(this.dir);\n    }\n\n    _setDirFromAngle() {\n        if (this.stateLock) return;\n        let moveDir = _utils_js__WEBPACK_IMPORTED_MODULE_0__.norm({\n            x: this.player.pos.x - this.pos.x,\n            y: this.player.pos.y - this.pos.y\n        });\n        let moveDirAngle = _utils_js__WEBPACK_IMPORTED_MODULE_0__.cos(moveDir, {x:0,y:-1});\n        let minAngleDiff = 2;\n        if (moveDir.x < 0) {\n            //[N, NW, W, SW, S]\n            let westDirs = [87, 152, 65, 148, 83];\n            westDirs.forEach((dirCode) => {\n                let dirVector = _utils_js__WEBPACK_IMPORTED_MODULE_0__.scaleVector(_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirToVector(dirCode), -1);\n                let angle = _utils_js__WEBPACK_IMPORTED_MODULE_0__.cos(dirVector, {x:0,y:-1});\n                let angleDiff = Math.abs(angle - moveDirAngle);\n                if (angleDiff < minAngleDiff) {\n                    minAngleDiff = angleDiff;\n                    this.dir = dirCode;\n                }\n            })\n        } else {\n            //[N, NE, E, SE, S]\n            let eastDirs = [87, 155, 68, 151, 83]\n            eastDirs.forEach((dirCode) => {\n                let dirVector = _utils_js__WEBPACK_IMPORTED_MODULE_0__.scaleVector(_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirToVector(dirCode), -1);\n                let angle = _utils_js__WEBPACK_IMPORTED_MODULE_0__.cos(dirVector, {x:0,y:-1});\n                let angleDiff = Math.abs(angle - moveDirAngle);\n                if (angleDiff < minAngleDiff) {\n                    minAngleDiff = angleDiff;\n                    this.dir = dirCode;\n                }\n            })\n        }\n    }\n\n    disperse(go, overlap) {\n        let error = Math.abs(_utils_js__WEBPACK_IMPORTED_MODULE_0__.dist(go.pos, this.pos) - (go.r + this.r - overlap));\n        let goToMe = _utils_js__WEBPACK_IMPORTED_MODULE_0__.scaleVector(_utils_js__WEBPACK_IMPORTED_MODULE_0__.norm({\n            x: this.pos.x - go.pos.x,\n            y: this.pos.y - go.pos.y\n        }), error);\n        let meToGo = _utils_js__WEBPACK_IMPORTED_MODULE_0__.scaleVector(goToMe, -1);\n        this.pos.x += goToMe.x;\n        this.pos.y += goToMe.y;\n        go.pos.x += meToGo.x;\n        go.pos.y += meToGo.y;\n    }\n    \n}\n\n//# sourceURL=webpack://js_project/./src/enemy.js?");

/***/ }),

/***/ "./src/game.js":
/*!*********************!*\
  !*** ./src/game.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Game)\n/* harmony export */ });\n/* harmony import */ var _scene_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scene.js */ \"./src/scene.js\");\n\n\nclass Game {\n    constructor(canvas) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.dimx = canvas.width;\n        this.dimy = canvas.height;\n        this.center = {x: this.dimx / 2, y: this.dimy / 2};\n        this.scene = new _scene_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this);\n        this.prevTime = Date.now();\n        this.dt = 0;\n        this.run();\n    }\n\n    run = () => {\n        let currentTime = Date.now();\n        this.dt = (currentTime - this.prevTime) / 1000;\n        this.prevTime = currentTime;\n        this.scene.run(this.dt);\n        // console.log(this.dt);\n        requestAnimationFrame(this.run);\n    }\n\n    restart() {\n        this.scene = new _scene_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this);\n    }\n}\n\n//# sourceURL=webpack://js_project/./src/game.js?");

/***/ }),

/***/ "./src/hitbox.js":
/*!***********************!*\
  !*** ./src/hitbox.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Hitbox)\n/* harmony export */ });\n/* harmony import */ var _sprite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sprite.js */ \"./src/sprite.js\");\n\n\nclass Hitbox extends _sprite_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor({ vel, pos, r, owner, dir}) {\n        super({\n            vel: vel, \n            pos: pos, \n            r: r\n        });\n        this.owner = owner;\n        this.dir = dir;\n    }\n\n    draw(ctx) {\n        ctx.fillStyle = \"red\";\n        ctx.beginPath();\n        ctx.arc(this.pos.x, this.pos.y, this.r, 0, 2 * Math.PI);\n        ctx.fill();\n    }\n}\n\n//# sourceURL=webpack://js_project/./src/hitbox.js?");

/***/ }),

/***/ "./src/hiteffect.js":
/*!**************************!*\
  !*** ./src/hiteffect.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ HitEffect)\n/* harmony export */ });\nclass HitEffect {\n    constructor(pos, scene, block) {\n        this.pos = pos;\n        this.scene = scene;\n        this.type = block ? 'block' : 'hit';\n        this.setSprite(`${this.type}_1`);\n        if (this.img) {\n            this.anchor = {\n                x: this.pos.x - (this.img.width / 2),\n                y: this.pos.y - (this.img.height / 2)\n            };\n        }\n\n        this.scene.addEffect(this);\n        this.timeSpawned = Date.now();\n    }\n\n    draw(ctx) {\n        let timeElapsed = Date.now() - this.timeSpawned;\n        if (timeElapsed < 100) {\n            this.setSprite(`${this.type}_1`);\n            ctx.drawImage(this.img, this.anchor.x, this.anchor.y);\n        } else  if (timeElapsed < 200) {\n            this.setSprite(`${this.type}_2`);\n            ctx.drawImage(this.img, this.anchor.x, this.anchor.y);\n        } else if (timeElapsed < 300) {\n            this.setSprite(`${this.type}_3`);\n            ctx.drawImage(this.img, this.anchor.x, this.anchor.y);\n        } else {\n            this.scene.removeEffect(this);\n        }\n    }\n\n    setSprite(frame) {\n        this.img = effectSprites[frame];\n    }\n}\n\n//# sourceURL=webpack://js_project/./src/hiteffect.js?");

/***/ }),

/***/ "./src/hud.js":
/*!********************!*\
  !*** ./src/hud.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Hud)\n/* harmony export */ });\nclass Hud {\n    constructor(scene) {\n        this.scene = scene;\n        this.dim = {x:this.scene.game.dimx, y:this.scene.game.dimy};\n        this.player = this.scene.player;\n    }\n\n    draw(ctx) {\n        if (this.scene.gameOver) {\n            this._gameOverScreen(ctx);\n            return;\n        }\n        let dim = this.dim;\n        let fontSize = 40;\n        let leftJust = 40;\n\n        let healthStr = `Health: ${this.player.health}`;\n        let scoreStr = `Score: ${this.scene.score}`;\n        let potionStr = `Potions: ${this.player.potions}`;\n        \n        ctx.font = `italic ${fontSize}px Times New Roman`;\n        ctx.textAlign = \"left\";\n        ctx.strokeStyle = \"black\";\n        ctx.lineWidth = 4;\n        ctx.fillStyle = this.player.color;\n\n        ctx.strokeText(healthStr, leftJust, 50);\n        ctx.fillText(healthStr, leftJust, 50);\n\n        ctx.fillStyle = \"white\"\n\n        ctx.strokeText(potionStr, leftJust, 100);\n        ctx.fillText(potionStr, leftJust, 100);\n\n        ctx.strokeText(scoreStr, leftJust, dim.y - 50);\n        ctx.fillText(scoreStr, leftJust, dim.y - 50);\n    }\n\n    _gameOverScreen(ctx) {\n        this._shadowOverlay(ctx);\n        \n        let dim = this.dim;\n        let fontSize = 80;\n        ctx.font = `italic ${fontSize}px Times New Roman`;\n        ctx.textAlign = \"center\";\n        ctx.strokeStyle = \"black\";\n        ctx.lineWidth = 4;\n        ctx.fillStyle = \"white\";\n\n        let fixY = dim.y / 2 - 40;\n        \n        let gameOverText = \"GAME OVER\"\n        ctx.strokeText(gameOverText, dim.x / 2, fixY - 40);\n        ctx.fillText(gameOverText, dim.x / 2, fixY - 40);\n\n        fontSize = 40;\n        ctx.font = `italic ${fontSize}px Times New Roman`;\n\n        let decoration = \"~\";\n        ctx.strokeText(decoration, dim.x / 2, fixY);\n        ctx.fillText(decoration, dim.x / 2, fixY);\n        \n        let firstFlavor = `You scored ${this.scene.score} points`;\n        ctx.strokeText(firstFlavor, dim.x / 2, fixY + 40);\n        ctx.fillText(firstFlavor, dim.x / 2, fixY + 40);\n\n        let secondFlavor = `and defeated ${this.player.killCount} enemies.`;\n        ctx.strokeText(secondFlavor, dim.x / 2, fixY + 100);\n        ctx.fillText(secondFlavor, dim.x / 2, fixY + 100);\n\n        fontSize = 30;\n        ctx.font = `italic ${fontSize}px Times New Roman`;\n        let restartFlavor = \"Press r to restart.\";\n        ctx.strokeText(restartFlavor, dim.x / 2, fixY + 160);\n        ctx.fillText(restartFlavor, dim.x / 2, fixY + 160);\n\n    }\n\n    _shadowOverlay(ctx) {\n        let dim = this.dim;\n        ctx.globalAlpha = 0.5;\n        ctx.fillStyle = \"black\";\n        ctx.fillRect(0, 0, dim.x, dim.y);\n        ctx.globalAlpha = 1;\n    }\n}\n\n//# sourceURL=webpack://js_project/./src/hud.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _game_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game.js */ \"./src/game.js\");\n/* harmony import */ var _assets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assets.js */ \"./src/assets.js\");\n\n\n\nconst canvas = document.getElementById(\"game-canvas\");\nconst ctx = canvas.getContext('2d');\nconst screenSizes = {\n    \"s\": [640, 480],\n    \"m\": [800, 600],\n    \"l\": [960, 720]\n};\nconst setSize = (size) => {\n    canvas.width = screenSizes[size][0];\n    canvas.height = screenSizes[size][1];\n}\n\nsetSize(\"m\");\nctx.fillStyle = \"black\";\nctx.fillRect(0, 0, canvas.width, canvas.height);\n\n(async () => {\n    await (0,_assets_js__WEBPACK_IMPORTED_MODULE_1__.loadAssets)();\n    const game = new _game_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](canvas);\n})();\n\n//# sourceURL=webpack://js_project/./src/index.js?");

/***/ }),

/***/ "./src/player.js":
/*!***********************!*\
  !*** ./src/player.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Player)\n/* harmony export */ });\n/* harmony import */ var _actor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actor.js */ \"./src/actor.js\");\n/* harmony import */ var _hiteffect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hiteffect.js */ \"./src/hiteffect.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n\n\n\n\nconst CONST = {\n    \"SPEED\": 400,\n    \"HEALTH\": 5,\n    \"MAXHEALTH\": 5,\n    \"MAXPOTS\": 3\n}\n\nclass Player extends _actor_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(pos, scene) {\n        super({\n            vel: {x: 0, y: 0}, \n            pos: pos, \n            r: 40, \n            img: playerSprites[148]['idle'],\n            health: CONST[\"HEALTH\"],\n            speed: CONST[\"SPEED\"],\n            color: \"white\"\n        }, scene);\n        this.mockPush = {x:0, y:0};\n        this.collisionCorrection = {x:0, y:0};\n        this.unscaledSpeed = this.speed;\n        this.strafe = false;\n        this.potions = 3;\n        this.killCount = 0;\n\n        this.states = {\n            \"idle\": [\"attack\", \"moving\", \"death\", \"heal\"],\n            \"attack\": [\"idle\", \"death\"],\n            \"moving\": [\"idle\", \"attack\", \"death\", \"heal\"],\n            \"death\": [],\n            \"heal\": [\"idle\", \"death\"]\n        };\n    }\n\n    blocking() {\n        return (this.state === 'idle' || this.state === 'moving') && this.strafe;\n    }\n\n    tick(dt) {\n        super.tick(dt);\n        if (this.state === \"heal\") this.heal();\n        if (this.strafe) {\n            this.speed = this.unscaledSpeed * 0.3;\n        }\n    }\n\n    idle() {\n        this.stateLock = false;\n        // console.log(\"i am idle!\");\n        this.setSprite('idle');\n        if (this.strafe) {\n            this.setSprite('strafe_1');\n        }\n    }\n\n    heal() {\n        this.stateLock = true;\n        this.setSprite('idle');\n        let timeElapsed = Date.now() - this.timeEnteredState;\n        if (timeElapsed < 200) {\n\n        } else if (timeElapsed < 400) {\n            if (!this.usedPotion){\n                this.usedPotion = true;\n                this.usePotion();\n            }\n        } else {\n            this.usedPotion = undefined;\n            this.stateLock = false;\n            this.changeState(\"idle\");\n        }\n    }\n\n    attack() {\n        let timeElapsed = Date.now() - this.timeEnteredState;\n        this.stateLock = true;\n        if (timeElapsed < 200) {\n            this.setSprite('attack_1');\n            if (!this.hitbox) {\n                this.hitbox = this.createHitbox();\n                this.scene.addHitbox(this.hitbox);\n            }\n        } else if (timeElapsed < 300) {\n            this.setSprite('attack_2');\n        } else if (timeElapsed < 400) {\n            this.setSprite('attack_3')\n            if (this.hitbox) {\n                this.scene.removeHitbox(this.hitbox);\n                this.hitbox = undefined;\n            }\n        } else {\n            this.stateLock = false;\n            this.changeState(\"idle\");\n        }\n    }\n\n    hit(hb) {\n        super.hit(hb);\n        if (this.health <= 0) this.scene.endGame();\n    }\n\n    blockCheck(hb) {\n        if (this.blocking()){ //Player is blocking\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_2__.blockedFromDir(this.dir, hb.dir)){ //block is successful\n                this.addHitEffect(hb, true);\n                this.successfulBlock = true;\n            } else { //block is unsuccessful\n                if (this.health > 0) this.health--;\n                this.addHitEffect(hb, false);\n                this.successfulBlock = undefined;\n            }\n        } else { //Player is not blocking\n            if (this.health > 0) this.health--;\n            this.addHitEffect(hb, false);\n            this.successfulBlock = undefined;\n        }\n    }\n\n    addHitEffect(hb, block) {\n        let effectPos = _utils_js__WEBPACK_IMPORTED_MODULE_2__.scaleVector(_utils_js__WEBPACK_IMPORTED_MODULE_2__.dirToVector(hb.dir), 20);\n        new _hiteffect_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n            x:effectPos.x + this.pos.x,\n            y:effectPos.y + this.pos.y\n        }, this.scene, block);\n    }\n\n    _hit(dt) {\n        let timeElapsed = Date.now() - this.timeHit;\n        if (timeElapsed < 400) {\n            this.pushBack(400 - timeElapsed, dt);\n            if (!this.successfulBlock) this.color = \"red\";\n            this.img.style.opacity = 0;\n        } else {\n            this.mockPush = {x:0,y:0}; \n            this.hitBy = undefined;\n            this.color = \"white\";\n        }\n    }\n\n    pushBack(factor, dt) {\n        let pushVector = _utils_js__WEBPACK_IMPORTED_MODULE_2__.dirToVector(this.hitBy.dir);\n        pushVector = _utils_js__WEBPACK_IMPORTED_MODULE_2__.scaleVector(pushVector, -1);\n        this.mockPush.x = pushVector.x * factor * dt * -1;\n        this.mockPush.y = pushVector.y * factor * dt * -1;\n    }\n\n    moving() {\n        this.speed = this.unscaledSpeed * _utils_js__WEBPACK_IMPORTED_MODULE_2__.dirScaleFactor(this.dir);\n        this.stateLock = false;\n        let timeElapsed = (Date.now() - this.timeEnteredState) % 800;\n        if (timeElapsed < 200) {\n            this.setSprite('move_1');\n            if (this.strafe) this.setSprite('strafe_3');\n        } else if (timeElapsed < 400) {\n            this.setSprite('move_2');\n            if (this.strafe) this.setSprite('strafe_2');\n        } else if (timeElapsed < 600) {\n            this.setSprite('move_3');\n            if (this.strafe) this.setSprite('strafe_1');\n        } else {\n            this.setSprite('move_4');\n            if (this.strafe) this.setSprite('strafe_2');\n        }\n    }\n\n    death() {\n\n    }\n\n    addHealth(amt) {\n        this.health += amt;\n        if (this.health >= CONST[\"MAXHEALTH\"]) this.health = CONST[\"MAXHEALTH\"];\n    }\n\n    addPotion() {\n        this.potions++;\n        if (this.potions >= CONST[\"MAXPOTS\"]) this.potions = CONST[\"MAXPOTS\"];\n    }\n\n    usePotion() {\n        if (this.potions > 0) {\n            this.addHealth(3);\n            this.potions--;\n        }\n    }\n\n    collisionHandle(bd) {\n        let error = Math.abs(bd.distToObj(this) - this.r);\n        let correction = _utils_js__WEBPACK_IMPORTED_MODULE_2__.scaleVector({x:bd.normal.x,y:bd.normal.y}, error);\n        this.collisionCorrection.x += correction.x;\n        this.collisionCorrection.y += correction.y;\n    }\n\n    setSprite(frame) {\n        this.img = playerSprites[this.dir][frame];\n    }\n\n}\n\n//# sourceURL=webpack://js_project/./src/player.js?");

/***/ }),

/***/ "./src/scene.js":
/*!**********************!*\
  !*** ./src/scene.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Scene)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n/* harmony import */ var _boundary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./boundary.js */ \"./src/boundary.js\");\n/* harmony import */ var _sprite_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sprite.js */ \"./src/sprite.js\");\n/* harmony import */ var _actor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./actor.js */ \"./src/actor.js\");\n/* harmony import */ var _enemy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./enemy.js */ \"./src/enemy.js\");\n/* harmony import */ var _player_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./player.js */ \"./src/player.js\");\n/* harmony import */ var _spawnpoint_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./spawnpoint.js */ \"./src/spawnpoint.js\");\n/* harmony import */ var _hud_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./hud.js */ \"./src/hud.js\");\n/* harmony import */ var _totem_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./totem.js */ \"./src/totem.js\");\n\n\n\n\n\n\n\n\n\n\nclass Scene {\n    constructor(game) {\n        this.game = game;\n        this.ctx = this.game.ctx;\n        this.center = game.center;\n        this.cameraDir = 0;\n        this.boundaries = [];\n        this.spawnPoints = [];\n        this.backgroundStatic = [];\n        this.gameObjects = [];\n        this.effects = [];\n        this.hitboxes = [];\n        this.player = new _player_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this.center, this);\n        this.foregroundStatic = [];\n        this.floorTileOffset = {x:100,y:57};\n\n        // this.addObjects();\n        this.addBackgroundStatic();\n        this.addBoundaries();\n        this.addSpawnPoints();\n\n        this.gameStart = false;\n        this.gameOver = false;\n        this.score = 0;\n\n        this.hud = new _hud_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](this);\n        this.gameObjects.push(new _totem_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"](\n            {x: this.terrainOrigin.x + (2 * this.floorTileOffset.x),\n                 y:this.terrainOrigin.y + (4 * this.floorTileOffset.y)},\n            this\n        ));\n    }\n    \n    run(dt) {\n        // console.log(dt);\n        // console.log(this.player.health);\n        if (this.gameOver) {\n            let keyCodes = key.getPressedKeyCodes();\n            if (keyCodes.includes(82)) {\n                this.game.restart();\n            }\n            this.drawObjects(this.ctx);\n            this.drawHud(this.ctx);\n        } else {\n            if (this.gameStart) this.incrementScore(dt);\n            this.tickStateMachines(dt);\n            this.getInputs();\n            this.checkCollisions();\n            this.moveObjects(dt);\n            this.translateObjects(dt);\n            this.hitDetection();\n            this.drawObjects(this.ctx);\n            this.drawHud(this.ctx);\n        }\n        // this.drawHitboxes(this.ctx); //for debugging\n        // this.drawBoundaries(this.ctx); //for debugging\n        // this.drawSpawnPoints(this.ctx); //for debugging\n    }\n\n    startGame() {\n        if (!this.gameStart) {\n            this.gameStart = true;\n            this.spawnInterval = setInterval(() => {\n                let sp = this.spawnPoints[(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.randInt)(this.spawnPoints.length)];\n                sp.spawnEnemy();\n            }, 2500)\n        }\n    }\n\n    endGame() {\n        this.gameOver = true;\n        clearInterval(this.spawnInterval);\n    }\n\n    addGameObject(obj) {\n        if (!this.gameObjects.includes(obj)) this.gameObjects.push(obj);\n    }\n\n    removeGameObject(obj) {\n        this.gameObjects.splice(this.gameObjects.indexOf(obj), 1);\n    }\n\n    addHitbox(hb) {\n        if (!this.hitboxes.includes(hb)) this.hitboxes.push(hb);\n    }\n\n    removeHitbox(hb) {\n        this.hitboxes.splice(this.hitboxes.indexOf(hb), 1);\n    }\n\n    addEffect(ef) {\n        if (!this.effects.includes(ef)) this.effects.push(ef);\n    }\n\n    removeEffect(ef) {\n        this.effects.splice(this.effects.indexOf(ef), 1);\n    }\n\n    incrementScore(dt) {\n        this.score += Math.floor(100 * dt);\n    }\n\n    tickStateMachines(dt) {\n        this.player.tick(dt);\n        let tickables = [...this.gameObjects, ...this.spawnPoints];\n        tickables.forEach((go) => go.tick(dt))\n    }\n\n    getInputs() {\n        // console.log(key.getPressedKeyCodes());\n        let keyCodes = key.getPressedKeyCodes();\n        this.processWasd(keyCodes);\n        if (keyCodes.includes(74)) { //74 = 'j'\n            this.player.changeState(\"attack\");\n        }\n        if (keyCodes.includes(73)) { //73 = 'i'\n            this.player.strafe = true;\n        } else {\n            this.player.strafe = false;\n        }\n        if (keyCodes.includes(79) && this.player.potions > 0) { //79 = 'o'\n            this.player.changeState(\"heal\");\n        }\n    }\n\n    processWasd(keyCodes) {\n        let wasd = [87, 65, 83, 68];\n        let reducedWasd = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.intersect)(wasd, keyCodes).slice(0,2);\n        let wasdSum = reducedWasd.reduce((acc, el) => {return acc + el}, 0);\n        if (wasdSum === 133 || wasdSum === 170) wasdSum = 0;\n        if (wasdSum !== 0 && !this.player.stateLock && !this.player.strafe) this.player.dir = wasdSum;\n        if (wasdSum === 0) {\n            this.player.changeState(\"idle\");\n        } else {\n            this.player.changeState(\"moving\");\n        }\n        if (this.player.state === \"moving\") {\n            this.cameraDir = wasdSum;\n        } else {\n            this.cameraDir = 0;\n        }\n    }\n\n    moveObjects(dt) {\n        this.gameObjects.forEach((go) => {\n            go.move(dt);\n        })\n    }\n\n    translateObjects(dt) {\n        let dir = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirToVector)(this.cameraDir);\n        let speed = this.player.speed;\n        let dpos = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.scaleVector)(dir, speed * dt);\n        dpos = {\n            x: dpos.x + this.player.mockPush.x + this.player.collisionCorrection.x,\n            y: dpos.y + this.player.mockPush.y + this.player.collisionCorrection.y\n        };\n        this.player.collisionCorrection.x = 0;\n        this.player.collisionCorrection.y = 0;\n        let sets = [\n            this.backgroundStatic, \n            this.gameObjects,\n            this.effects,\n            this.hitboxes, \n            this.spawnPoints, \n            this.boundaries, \n            this.foregroundStatic\n        ];\n        sets.forEach((set) => {\n            set.forEach((el) => {\n                el.pos.x += dpos.x;\n                el.pos.y += dpos.y;\n            })\n        })\n    }\n\n    hitDetection() {\n        this.gameObjects.forEach((go) => {\n            this.hitboxes.forEach((hb) => {\n                if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.dist)(go.pos, hb.pos) < go.r + hb.r && hb.owner === this.player) {\n                    go.hit(hb);\n                }\n            })\n        })\n        this.hitboxes.forEach((hb) => {\n            if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.dist)(this.player.pos, hb.pos) < this.player.r + hb.r && hb.owner !== this.player){\n                this.player.hit(hb);\n            }\n        })\n    }\n\n    checkCollisions() {\n        this.boundaries.forEach((bd) => {\n            //check for collision with game objects\n            this.gameObjects.forEach((go) => {\n                if (bd.distToObj(go) < go.r) go.collisionHandle(bd);\n            })\n            //check for collision with player\n            if (bd.distToObj(this.player) < this.player.r) {\n                this.player.collisionHandle(bd);\n            }\n        })\n        let enemyOverlap = 20;\n        for (let i = 1; i < this.gameObjects.length; i++) {\n            for (let j = 0; j < i; j++) {\n                let go1 = this.gameObjects[i];\n                let go2 = this.gameObjects[j];\n                if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.dist)(go1.pos, go2.pos) < (go1.r + go2.r) - enemyOverlap) go1.disperse(go2, enemyOverlap);\n            }\n        }\n    }\n\n    drawObjects(ctx) {\n        //clear screen\n        ctx.clearRect(0, 0, this.game.dimx, this.game.dimy);\n        ctx.fillStyle = \"black\";\n        ctx.fillRect(0, 0, this.game.dimx, this.game.dimy);\n        //draw bg elements\n        this.backgroundStatic.forEach((go) => {\n            go.draw(ctx);\n        })\n        //draw actors based off y pos\n        let actors = [...this.gameObjects, ...this.spawnPoints, this.player]; //actors = all game objects including player\n        actors = actors.sort((a,b) => (a.pos.y > b.pos.y) ? 1 : -1); //sort based off y-pos\n        for (let i = 0; i < actors.length; i++) { //loop thru actors, render furthest back FIRST\n            actors[i].draw(ctx);\n        }\n        //draw effects\n        this.effects.forEach((ef) => {\n            ef.draw(ctx);\n        })\n        //draw fg elements\n        this.foregroundStatic.forEach((go) => {\n            go.draw(ctx);\n        })\n    }\n\n    drawHud(ctx) {\n        this.hud.draw(ctx);\n    }\n\n    drawHitboxes(ctx) {\n        this.hitboxes.forEach((hb) => {\n            hb.draw(ctx);\n        })\n    }\n\n    drawBoundaries(ctx) {\n        this.boundaries.forEach((bd) => {\n            bd.draw(ctx);\n        })\n    }\n\n    drawSpawnPoints(ctx) {\n        this.spawnPoints.forEach((sp) => {\n            sp.draw(ctx);\n        })\n    }\n\n    addBackgroundStatic() {\n        let offset = this.floorTileOffset; //Proper spacing between tiles\n        let wallStart = {x:this.game.dimx / 2, y: offset.y * -2}; //Start point for wall tiles\n        let rightWall = {x:wallStart.x, y:wallStart.y};\n        for (let i = 0; i < 11; i++) { //Render right side wall\n            let randomJitter = (Math.random() * 20);\n            let wall = new _sprite_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                pos: {\n                    x: rightWall.x,\n                    y: rightWall.y + randomJitter\n                },\n                img: bgSprites['wall0']\n            });\n            this.backgroundStatic.push(wall); //lower level\n            wall = new _sprite_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                pos: {\n                    x: rightWall.x,\n                    y: rightWall.y - 128 + randomJitter\n                },\n                img: bgSprites['wall0']\n            });\n            this.backgroundStatic.push(wall); //upper level\n            rightWall.x += offset.x;\n            rightWall.y += offset.y;\n        }\n        let leftWall = {x:wallStart.x - offset.x, y:wallStart.y + offset.y};\n        for (let i = 0; i < 10; i++) { //Render left side wall\n            let randomJitter = (Math.random() * 20);\n            let wall = new _sprite_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                pos: {\n                    x: leftWall.x,\n                    y: leftWall.y + randomJitter\n                },\n                img: bgSprites['wall0']\n            });\n            this.backgroundStatic.push(wall); //lower level\n            wall = new _sprite_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                pos: {\n                    x: leftWall.x,\n                    y: leftWall.y - 128 + randomJitter\n                },\n                img: bgSprites['wall0']\n            });\n            this.backgroundStatic.push(wall); //upper level\n            leftWall.x -= offset.x;\n            leftWall.y += offset.y;\n        }\n        let initialPos = {x:this.game.dimx / 2, y: 0}; //Start point for floor tiles\n        this.terrainOrigin = {x:initialPos.x, y:initialPos.y};\n        let rowStart = {x:initialPos.x, y:initialPos.y};\n        for (let i = 0; i < 10; i++) { //Render floor tiles\n            let column = {x:rowStart.x, y:rowStart.y};\n            for (let j = 0; j < 10; j++) {\n                let tile = new _sprite_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                    pos: {\n                        x: column.x,\n                        y: column.y + (Math.random() * 20)\n                    },\n                    img: bgSprites[`ground${(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.randInt)(2)}`]\n                });\n                this.backgroundStatic.push(tile);\n                column.x += offset.x;\n                column.y += offset.y;\n            }\n            rowStart.x -= offset.x;\n            rowStart.y += offset.y;\n        }\n    }\n\n    addBoundaries() {\n        let nw = new _boundary_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n            pos: {\n                x: (this.terrainOrigin.x) - (10 * this.floorTileOffset.x),\n                y: (8 * this.floorTileOffset.y)\n            },\n            delta: {\n                x: 10 * this.floorTileOffset.x,\n                y: 10 * -this.floorTileOffset.y\n            },\n            normal: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirToVector)(151)\n        });\n        this.boundaries.push(nw);\n        let ne = new _boundary_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n            pos: {\n                x: (this.terrainOrigin.x) + (10 * this.floorTileOffset.x),\n                y: (8 * this.floorTileOffset.y)\n            },\n            delta: {\n                x: 10 * -this.floorTileOffset.x,\n                y: 10 * -this.floorTileOffset.y\n            },\n            normal: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirToVector)(148)\n        });\n        this.boundaries.push(ne);\n        let se = new _boundary_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n            pos: {\n                x: (this.terrainOrigin.x) + (10 * this.floorTileOffset.x),\n                y: (8.6 * this.floorTileOffset.y)\n            },\n            delta: {\n                x: 10 * -this.floorTileOffset.x,\n                y: 10 * this.floorTileOffset.y\n            },\n            normal: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirToVector)(152)\n        });\n        this.boundaries.push(se);\n        let sw = new _boundary_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n            pos: {\n                x: (this.terrainOrigin.x) - (10 * this.floorTileOffset.x),\n                y: (8.6 * this.floorTileOffset.y)\n            },\n            delta: {\n                x: 10 * this.floorTileOffset.x,\n                y: 10 * this.floorTileOffset.y\n            },\n            normal: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirToVector)(155)\n        });\n        this.boundaries.push(sw);\n    }\n\n    addSpawnPoints() {\n        let start = this.terrainOrigin;\n        let offset = this.floorTileOffset;\n        let points = [\n            {x:start.x, y:start.y - offset.y}, //north\n            {x:start.x - (9 * offset.x), \n                y:start.y + (8 * offset.y)}, //west\n            {x:start.x + (9 * offset.x), \n                y:start.y + (8 * offset.y)}, //east\n            {x:start.x, \n            y:start.y + (17 * offset.y)}, //south\n            {x:start.x - (4.5 * offset.x),\n                y:start.y + (3.5 * offset.y)}, //north west\n            {x:start.x + (4.5 * offset.x),\n                y:start.y + (3.5 * offset.y)}, //north east\n            {x:start.x + (4.5 * offset.x),\n                y:start.y + (12.5 * offset.y)}, //south east\n            {x:start.x - (4.5 * offset.x),\n                y:start.y + (12.5 * offset.y)}, //south west\n        ];\n        points.forEach((point) => {\n            let sp = new _spawnpoint_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]({pos: point}, this);\n            this.spawnPoints.push(sp);\n        })\n    }\n\n    addObjects() {\n        this.gameObjects.push(new _enemy_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](\n            {\n                x: this.game.dimx / 2 - 100,\n                y: this.game.dimy / 2 + 50\n            },\n            this\n        ));\n        this.gameObjects.push(new _enemy_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](\n            {\n                x: this.game.dimx / 2 + 100,\n                y: this.game.dimy / 2 + 50\n            },\n            this\n        ));\n        this.gameObjects.push(new _enemy_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](\n            {\n                x: this.game.dimx / 2 + 50,\n                y: this.game.dimy / 2 + 150\n            },\n            this\n        ));\n    }\n}\n\n//# sourceURL=webpack://js_project/./src/scene.js?");

/***/ }),

/***/ "./src/spawnpoint.js":
/*!***************************!*\
  !*** ./src/spawnpoint.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SpawnPoint)\n/* harmony export */ });\n/* harmony import */ var _enemy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enemy */ \"./src/enemy.js\");\n\n\nclass SpawnPoint {\n    constructor({ pos }, scene) {\n        this.pos = pos\n        if (!pos) this.pos = {x:0,y:0};\n        this.scene = scene;\n        this.spawning = false;\n        this.enemy = undefined;\n    }\n\n    tick(dt) {\n        if (this.spawning) {\n            let timeElapsed = Date.now() - this.timeActivated;\n            if (timeElapsed < 200) {\n                this.setSprite('spawn_3');\n            } else if (timeElapsed < 400) {\n                this.setSprite('spawn_2');\n            } else if (timeElapsed < 600) {\n                this.setSprite('spawn_1');\n            } else if (timeElapsed < 700) {\n                if (!this.enemy) {\n                    this.enemy = new _enemy__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({x:this.pos.x, y:this.pos.y}, this.scene)\n                    this.scene.addGameObject(this.enemy);\n                }\n            } else if (timeElapsed < 800) {\n                this.setSprite('spawn_2');\n            } else if (timeElapsed < 1000) {\n                this.setSprite('spawn_3');\n            } else {\n                this.img = undefined;\n                this.spawning = false;\n                this.enemy = undefined;\n            }\n        }\n    }\n\n    spawnEnemy() {\n\n        this.timeActivated = Date.now();\n        this.spawning = true;\n    }\n\n    setSprite(frame) {\n        this.img = effectSprites[frame];\n    }\n\n    draw(ctx) {\n        // ctx.fillStyle = \"purple\";\n        // ctx.beginPath();\n        // ctx.arc(this.pos.x, this.pos.y, 10, 0, 2 * Math.PI);\n        // ctx.fill();\n        if (this.img) {\n            ctx.drawImage(this.img, this.pos.x - (this.img.width / 2), this.pos.y - (this.img.height / 2));\n        }\n    }\n}\n\n//# sourceURL=webpack://js_project/./src/spawnpoint.js?");

/***/ }),

/***/ "./src/sprite.js":
/*!***********************!*\
  !*** ./src/sprite.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Sprite)\n/* harmony export */ });\nclass Sprite {\n    constructor({ vel, pos, r, img, color }) {\n        if (!vel) { this.vel = {x:0, y:0}; }\n        else {this.vel = vel;}\n        if (!pos) { this.pos = {x:0,y:0};}\n        else {this.pos = pos;}\n        if (!r) { this.r = 20;}\n        else {this.r = r;}\n        if (!color) { this.color = \"white\";}\n        else {this.color = color;}\n        this.img = img;\n        // this.sprite = new Image(); \n        // this.sprite.src = this.img;\n        if (img) {\n            this.anchor = {\n                x: this.pos.x - (this.img.width / 2),\n                y: this.pos.y - (this.img.height / 2)\n            };\n        }\n    }\n\n    draw(ctx) {\n        if (!this.img) {\n            ctx.fillStyle = this.color;\n            ctx.beginPath();\n            ctx.arc(this.pos.x, this.pos.y, this.r, 0, 2 * Math.PI);\n            ctx.fill();\n        } else {\n            // ctx.fillStyle = this.color;\n            // ctx.beginPath();\n            // ctx.arc(this.pos.x, this.pos.y, this.r, 0, 2 * Math.PI);\n            // ctx.fill();\n\n            this._updateAnchor();\n            ctx.drawImage(this.img, this.anchor.x, this.anchor.y);\n        }\n    }\n\n    _updateAnchor() {\n        this.anchor = {\n            x: this.pos.x - (this.img.width / 2),\n            y: this.pos.y - (this.img.height / 2)\n        };\n    }\n\n    move(dt) {\n        this.pos.x += (this.vel.x * dt);\n        this.pos.y += (this.vel.y * dt);\n    }\n}\n\n//# sourceURL=webpack://js_project/./src/sprite.js?");

/***/ }),

/***/ "./src/totem.js":
/*!**********************!*\
  !*** ./src/totem.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Totem)\n/* harmony export */ });\n/* harmony import */ var _actor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actor */ \"./src/actor.js\");\n\n\nclass Totem extends _actor__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(pos, scene) {\n        super({pos: pos});\n        this.scene = scene;\n    }\n\n    hit(hb){\n        this.scene.startGame();\n        super.hit(hb);\n    }\n}\n\n//# sourceURL=webpack://js_project/./src/totem.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"blockedFromDir\": () => (/* binding */ blockedFromDir),\n/* harmony export */   \"cos\": () => (/* binding */ cos),\n/* harmony export */   \"dirScaleFactor\": () => (/* binding */ dirScaleFactor),\n/* harmony export */   \"dirToVector\": () => (/* binding */ dirToVector),\n/* harmony export */   \"dist\": () => (/* binding */ dist),\n/* harmony export */   \"dot\": () => (/* binding */ dot),\n/* harmony export */   \"intersect\": () => (/* binding */ intersect),\n/* harmony export */   \"mag\": () => (/* binding */ mag),\n/* harmony export */   \"norm\": () => (/* binding */ norm),\n/* harmony export */   \"randInt\": () => (/* binding */ randInt),\n/* harmony export */   \"scaleVector\": () => (/* binding */ scaleVector)\n/* harmony export */ });\nconst norm = (vector) => {\n    let mag = dist(vector, {x:0,y:0});\n    return {\n        x: vector.x / mag,\n        y: vector.y / mag\n    }\n};\n\nconst dot = (v1, v2) => {\n    return (\n        (v1.x * v2.x) + (v1.y * v2.y)\n    ) // / (mag(v1) * mag(v2));\n};\n\nconst mag = (vector) => {\n    return dist(vector, {x:0,y:0});\n};\n\nconst cos = (v1, v2) => {\n    return dot(v1, v2) / (mag(v1) * mag(v2));\n};\n\nconst intersect = (arr1, arr2) => {\n    let set1 = new Set(arr1);\n    let set2 = new Set(arr2);\n    let res = new Set([...set1].filter(i => set2.has(i)));\n    return Array.from(res);\n};\n\nconst scaleVector = (vector, c) => {\n    return {\n        x: vector.x * c,\n        y: vector.y * c\n    }\n};\n\nconst dist = (v1, v2) => {\n    return Math.sqrt(\n        (v1.x - v2.x)**2 + (v1.y-v2.y)**2\n    );\n};\n\nconst randInt = (max) => {\n    return Math.floor(Math.random() * max);\n}\n\nconst dirToVector = (dirCode) => {\n    // const directionVectors = { //Octagonal\n    //     87: {x: 0, y: 1}, //w\n    //     65: {x: 1, y: 0}, //a\n    //     83: {x: 0, y: -1}, //s\n    //     68: {x: -1, y: 0}, //d\n    //     155: {x: -0.707, y: 0.707}, //wd\n    //     152: {x: 0.707, y: 0.707}, //wa\n    //     151: {x: -0.707, y: -0.707}, //sd\n    //     148: {x: 0.707, y: -0.707}, //sa\n    //     0: {x: 0, y: 0}\n    // };\n    const directionVectors = { //Isometric-accurate\n        87: {x: 0, y: 1}, //w N\n        65: {x: 1, y: 0}, //a W\n        83: {x: 0, y: -1}, //s S\n        68: {x: -1, y: 0}, //d E\n        155: {x: -0.866, y: 0.5}, //wd NE\n        152: {x: 0.866, y: 0.5}, //wa NW\n        151: {x: -0.866, y: -0.5}, //sd SE\n        148: {x: 0.866, y: -0.5}, //sa SW\n        0: {x: 0, y: 0}\n    };\n    return directionVectors[dirCode];\n};\n\nconst dirScaleFactor = (dirCode) => {\n    if (dirCode === 87 || dirCode === 83) return 0.577;\n    if (dirCode === 65 || dirCode === 68) return 1;\n    return mag({x:0.707,y:0.408});\n};\n\nconst blockedFromDir = (blockDir, attackDir) => {\n    let res = false;\n    switch (blockDir) {\n        case 87: //N\n            res = [83, 151, 148].includes(attackDir);\n            break;\n        case 155: //NE\n            res = [65, 83, 148].includes(attackDir);\n            break;\n        case 68: //E\n            res = [65, 148, 152].includes(attackDir);\n            break;\n        case 151: //SE\n            res = [152, 87, 65].includes(attackDir);\n            break;\n        case 83: //S\n            res = [87, 155, 152].includes(attackDir);\n            break;\n        case 148: //SW\n            res = [155, 87, 68].includes(attackDir);\n            break;\n        case 65: //W\n            res = [68, 155, 151].includes(attackDir);\n            break;\n        case 152: //NW\n            res = [151, 83, 68].includes(attackDir);\n            break;\n    }\n    return res;\n};\n\n//# sourceURL=webpack://js_project/./src/utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;